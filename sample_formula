; Accepting NFA: f0p, d0pa1p, d1pa0p
; Rejecting NFA: f1pp, d0ppb1pp, d1ppb1pp


(set-option :produce-models true) ; enable model generation
(set-option :produce-proofs true) ; enable proof generation

; final states in DFA
(declare-const f0 Bool)
(declare-const f1 Bool)

; match up w/ accepting NFA
(declare-const x00p Bool)
(declare-const x01p Bool)
(declare-const x10p Bool)
(declare-const x11p Bool)

; match up w/ rejecting NFA
(declare-const y01pp Bool)
(declare-const y00pp Bool)
(declare-const y11pp Bool)
(declare-const y10pp Bool)

; transitions in DFA
(declare-const d0a0 Bool)
(declare-const d0a1 Bool)
(declare-const d1a0 Bool)
(declare-const d1a1 Bool)
(declare-const d0b0 Bool)
(declare-const d0b1 Bool)
(declare-const d1b0 Bool)
(declare-const d1b1 Bool)


; assert DFA not NFA
(assert (or (not d0a0) (not d0a1)))
(assert (or (not d1a0) (not d1a1)))
(assert (or (not d0b0) (not d0b1)))
(assert (or (not d1b0) (not d1b1)))

; assert DFA's transition function is total (i.e. complete DFA)
(assert (or d0a0 d0a1))
(assert (or d1a0 d1a1))
(assert (or d0b0 d0b1))
(assert (or d1b0 d1b1))

; assert start states
(assert x00p)
(assert y00pp)

; assert transitions from accepting NFA
(assert (=> (and x00p d0a0) x01p))
(assert (=> (and x00p d0a1) x11p))
(assert (=> (and x01p d0a0) x00p))
(assert (=> (and x01p d0a1) x10p))
(assert (=> (and x10p d1a0) x01p))
(assert (=> (and x10p d1a1) x11p))
(assert (=> (and x11p d1a0) x00p))
(assert (=> (and x11p d1a1) x10p))

; assert transitions from rejecting NFA
(assert (=> (and y01pp d0b0) y01pp))
(assert (=> (and y01pp d0b1) y11pp))
(assert (=> (and y00pp d0b0) y01pp))
(assert (=> (and y00pp d0b1) y11pp))
(assert (=> (and y11pp d1b0) y01pp))
(assert (=> (and y11pp d1b1) y11pp))
(assert (=> (and y10pp d1b0) y01pp))
(assert (=> (and y10pp d1b1) y11pp))

; add final-state constraints
(assert (=> x00p f0))
(assert (=> x10p f1))

(assert (=> y01pp (not f0) ))
(assert (=> y11pp (not f1) ))

(check-sat)
(get-model)
